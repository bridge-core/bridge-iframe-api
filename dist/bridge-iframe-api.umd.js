(function(n,a){typeof exports=="object"&&typeof module!="undefined"?a(exports):typeof define=="function"&&define.amd?define(["exports"],a):(n=typeof globalThis!="undefined"?globalThis:n||self,a(n.BridgeIframeAPI={}))})(this,function(n){"use strict";class a{constructor(e=window.top){if(this.listeners=new Map,this.awaitingResponse=new Map,!e)throw new Error("You must provide a valid target in order to create a channel");this.target=e}get port(){if(!this._port)throw new Error("You must open the channel/connect to a channel before triggering events");return this._port}open(){return new Promise(e=>{globalThis.addEventListener("message",async t=>{t.data!=="bridge-editor:connect"||t.ports.length===0||(this._port=t.ports[0],this.startListening(),await this.trigger("bridge-editor:connected",null),e())},{once:!0}),this.target.postMessage("bridge-editor:connection-request","*")})}connect(){const e=new MessageChannel;return this._port=e.port1,this.startListening(),globalThis.addEventListener("bridge-editor:connection-request",()=>{this.target.postMessage("bridge-editor:connect","*",[e.port2])},{once:!0}),new Promise(t=>{this.on("bridge-editor:connected",()=>{t()})})}startListening(){this.port.addEventListener("message",async e=>{const{type:t,noResponse:r,origin:d,uuid:s,error:h,payload:p}=e.data;if(t==="response"){const o=this.awaitingResponse.get(s);if(!o){console.error(`No response handler for ${s}`);return}o(p,h),this.awaitingResponse.delete(s);return}const i=this.listeners.get(t);if(!i)return;let l=null,g;try{l=await i(p,d)}catch(o){g=typeof o=="string"?o:o.message}r||this.respond(s,l,g)}),this.port.start()}respond(e,t,r){this.port.postMessage({type:"response",uuid:e,origin:window.origin,error:r,payload:t})}trigger(e,t,r){return new Promise((d,s)=>{const h=(l,g)=>{if(g){s(g);return}p&&clearTimeout(p),d(l)},p=r?setTimeout(()=>{this.awaitingResponse.delete(i),s(new Error("Response timed out"))},r):null,i=crypto.randomUUID();this.awaitingResponse.set(i,h),this._simpleTrigger(e,t,i)})}_simpleTrigger(e,t,r=crypto.randomUUID(),d){this.port.postMessage({type:e,noResponse:d,uuid:r,origin:window.origin,payload:t})}simpleTrigger(e,t){this._simpleTrigger(e,t,void 0,!0)}on(e,t){if(e==="response")throw new Error('The "response" event type is reserved for internal use.');if(this.listeners.has(e))throw new Error(`Event handler for event "${e}" already exists`);return this.listeners.set(e,t),{dispose:()=>{this.listeners.delete(e)}}}}n.Channel=a,Object.defineProperties(n,{__esModule:{value:!0},[Symbol.toStringTag]:{value:"Module"}})});
